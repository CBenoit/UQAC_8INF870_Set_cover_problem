%!TEX program = lualatex
\documentclass[12pt,letterpaper,twoside]{article}
\include{packages}
\include{settings}

\bibliography{references}
\nocite{*}

\begin{document}
	\maketitle{}
	\tableofcontents{}
	\newpage{}
	\section{Définition du problème}
		\subsection{SCP et WSCP}
			\paragraph*{Présentation\\}
				Le problème de couverture d'ensemble, ou \emph{Set Covering Problem} (SCP),
				fait parti des 21 problèmes NP-complets de \citeauthor{Karp1972}~\cite{Karp1972}
				et est NP-complet au sens fort \cite{garey2002computers}.
			\paragraph*{Problème de couverture d'ensemble\\}
				Étant donné un ensemble univers \(U = \{u_1, u_2, u_3, \dots, u_m\}\) et une famille \(S = \{s_1, s_2, \dots, s_n\}\) de sous-ensembles de \(U\),
				le problème consiste à trouver une sous-famille de \(S\) la plus petite possible permettant de couvrir chaque élément de \(U\)
				au moins une fois. Un élément \(e\) de \(U\) est couvert par un sous-ensemble \(A\) si \(e \in A\).
			\paragraph*{Problème de couverture d'ensemble pondéré\\}
				En associant un coût positif \(c_i\) à chaque sous-ensemble, on obtient le problème de couverture d'ensemble pondéré ou \emph{Weighted Set Covering Problem} (WSCP) et	l'objectif est alors de déterminer une couverture de coût minimum.~\cite{Vazirani2003}
		\subsection{Utilité}
			\paragraph*{}
				Une grande variété de problèmes de positionnement, de distribution, de planification et autres peuvent être formulés comme variantes du problème de couverture d'ensemble. Parmi les problèmes réels auxquels cette approche a été appliquée avec succès:\cite{Balas1982}
				\begin{itemize}
					\item problèmes de sélection de sites et d'allocation d'emplacement
					\item emplacement des installations des services d'urgence (casernes de pompiers, hôpitaux, etc.)
					\item choix de la taille et de l'emplacement des plates-formes de forage dans les champs pétrolifères en mer
					\item horaire des équipages pour les compagnies aériennes, les compagnies de bus, les chemins de fer
					\item répartition des fréquences de radiodiffusion entre stations de radio ou de télévision
					\item recherche d'informations (à partir de fichiers informatiques)
					\item \ldots
				\end{itemize}
	\section{Exemple minimal}
		\subsection{SCP}
			\paragraph*{}
				Soit un ensemble univers \(U = \{u_1, u_2, \dots, u_{12}\}\) (représenté par des points sur le figure \ref{fig:example}) et une famille \(S = \{s_1, s_2, \dots, s_6\}\) de sous-ensembles de \(U\) (représentés par des rectangles sur la figure \ref{fig:example}) avec:
				\begin{itemize}
					\item \(s_1 = \{u_1, u_2, u_3, u_4, u_5, u_6\}\)
					\item \(s_2 = \{u_5, u_6, u_8, u_9\}\)
					\item \(s_3 = \{u_1, u_4, u_7, u_{10}\}\)
					\item \(s_4 = \{u_2, u_5, u_8, u_{11}\}\)
					\item \(s_5 = \{u_3, u_6, u_9, u_{12}\}\)
					\item \(s_6 = \{u_{10}, u_{11}, u_{12}\}\)
				\end{itemize}
			\paragraph*{}
				La solution optimale à cette instance est la sous famille \(S'=\{s_3, s_4, s_5\}\) (colorée en gris sur la figure \ref{fig:example}).
			\begin{figure}[H]
				\centering%
				\includegraphics[width=0.65\linewidth]{figures/example}%
				\caption{Exemple d'instance du Set Cover Problem et solution optimale\cite{Mount2017}}%
				\label{fig:example}%
			\end{figure}
		\subsection{WSCP}
			TODO
	\section{Complexité}
		\paragraph*{}
			Le SCP est un problème d'optimisation NP-difficile, et NP-complet dans sa forme décisionnelle. IL fait notamment parti des 21 problèmes NP-complets de \citeauthor{Karp1972}~\cite{Karp1972} et est NP-complet au sens fort \cite{garey2002computers}.
		\paragraph*{}
			La démonstration de la NP-complétude du problème a été réalisée par \citeauthor{Karp1972} en \citeyear{Karp1972} dans son article \citetitle{Karp1972}\cite{Karp1972}. Dans cet article, il réalise des réductions pour 21 problèmes réputés difficiles de combinatoire et de théorie des graphes comme représenté sur la figure \ref{fig:karp_reduction_tree}.
		\begin{figure}[H]
			\centering%
			\includegraphics[width=\linewidth]{karp_reduction_tree}%
			\caption{Arbre des réductions réalisées par Karp\cite{Karp1972}}%
			\label{fig:karp_reduction_tree}%
		\end{figure}
		\paragraph*{}
			Concernant notre problème, \citeauthor{Karp1972} montre donc que le Boolean Satisfiability Problem (SATISFIABILITY) peut être réduit au Clique Problem (CLIQUE) qui peut etre réduit au Vertex/Node Cover Problem (NODE COVER) qui peut être réduit au Set Covering Problem (SET COVERING).
		\paragraph*{}
			Le théorème de Cook–Levin et sa démonstration publié en \citeyear{Cook1971} par \citeauthor{Cook1971} dans l'article \citetitle{Cook1971}\cite{Cook1971} prouve le Boolean Satisfiability Problem comme étant un problème NP-complet. Par réduction, le Set Covering Problem est donc aussi NP-complet.
		\paragraph*{}
			Pour ce qui est du Weighted Set Covering Problem (WSCP), c'est une généralisation du SCP et la réduction de ce dernier est évidente, il suffit de rajouter des poids tous égaux a une instance de SCP pour obtenir une instance de WSCP équivalente, le WSCP est donc lui aussi NP-complet.
	\section{État de l'art}
		\paragraph*{}
			Les algorithmes présentés dans cette section utilisent souvent le modèle de la relaxation lagrangienne.
			Cette relaxation consiste à supprimer des contraintes difficiles en les intégrant dans la fonction objectif en tant que pénalités.
			Les coefficients appliqués sont dans ce qu'on appelle le « vecteur multiplicateur de lagrange ».~\cite{fisher1985applications}
		\subsection{Méthodes exactes}
			\paragraph*{}
				La plupart des méthodes exactes les plus efficaces pour résoudre le problème de couverture d'ensemble sont
				des méthodes branch-and-bound
				dans lesquelles on calcule les bornes inférieures à l'aide d'une relaxation du problème en programmation
				linéaire.~\cite{caprara2000algorithms}
			\paragraph*{}
				\citeauthor{Beasley1987} a proposé un algorithme qui fonctionne de cette façon.
				Le nœud racine utilise la solution du programme linéaire relaxé, puis les bornes inférieures
				sont calculées à l'aide de la relaxation lagrangienne avec la descente de sous-gradient.~\cite{Beasley1987}
		\subsection{Méthodes approchées}
			\subsubsection{Méthodes voraces non optimales}\label{sec:soa-greedy}
				\paragraph*{}
					\citeauthor{Johnson:1973:AAC:800125.804034} a présenté dans son papier \citetitle{Johnson:1973:AAC:800125.804034}
					l'algorithme vorace standard pour le problème de couverture d'ensemble non pondéré.
					L'algorithme prend simplement le sous-ensemble qui couvre le plus
					d'éléments à chaque étape jusqu'à obtenir une solution valide. La complexité de l'algorithme est en \(O(mn)\) avec \(m\)
					le nombre d'éléments et \(n\) le nombre de sous-ensembles.~\cite{Johnson:1973:AAC:800125.804034}
					Cet algorithme n'est pas très efficace sur un problème de couverture d'ensemble pondéré car il n'en tient pas du
					tout compte.
				\paragraph*{}
					\citeauthor{Cormen:2009:IAT:1614191} ont présenté une version de l'algorithme utilisant une queue à priorité,
					permettant d'améliorer la vitesse de l'algorithme.~\cite{Cormen:2009:IAT:1614191}
				\paragraph*{}
					\citeauthor{Goldschmidt:1993:MGH:177276.177287} ont proposé une solution qui fonctionne en appliquant des
					combinaisons de plusieurs algorithmes. Des algorithmes approchés et exacts sont utilisés.
					La méthode exploite le fait qu'il est possible de trouver la solution optimale pour des ensembles de taille 2 au maximum
					en un temps polynomial. On exécute l'algorithme vorace standard de Johnson jusqu'à obtenir une taille maximale de 2 pour les
					ensembles, puis trouve la couverture optimale pour le reste, ce qui donne une solution améliorée.~\cite{Goldschmidt:1993:MGH:177276.177287}
			\subsubsection{Heuristiques}
				\paragraph*{}
					De nombreuses méthodes par heuristique sont basées sur l'observation que pour un vecteur multiplicateur de lagrange quasi-optimal
					le coût de lagrange donne une information fiable sur l'utilité générale de la sélection d'un sous-ensemble donné.
					De là, plutôt que d'utiliser les coûts originaux, on utilise les coûts de lagrange pour calculer les scores permettant
					de classer les différents sous-ensembles à sélectionner pour la solution optimale. Ces scores sont donnés
					à un algorithme vorace pour obtenir une solution valide.~\cite{caprara2000algorithms}
				\paragraph*{}
					\citeauthor{Beasley1990} a proposé un algorithme qui calcule à chaque itération de l'optimisation par sous-gradient une
					solution valide de la façon suivante : un ensemble \(S\) est initialisé avec les sous-ensembles sélectionnés
					par la solution de la relaxation lagrangienne. Puis, pour chaque point non couvert par \(S\),
					le sous ensemble avec le coût original le plus faible est ajouté à \(S\). Pour finir, les différents sous-ensembles
					de \(S\) sont considérés par ordre de coût original décroissant et on enlève le sous-ensemble \(j\) si \(S \backslash \{j\}\)
					est toujours une solution valide. À chaque itération on effectue un fixage de coût de lagrange pour réduire la taille
					du problème.~\cite{Beasley1990}	
				\paragraph*{}
					\citeauthor{jacobs1995lsh} ont proposée une approche basée sur le recuit simulé. Une solution initiale \(S\)
					est générée par un algorithme vorace qui à chaque itération sélectionne aléatoirement un point non couvert
					et ajoute à la solution le premier sous-ensemble qui couvre ce point. Après cette addition, les colonnes
					redondantes sont enlevées de la solution, et le processus est continué jusqu'à l'obtention d'une solution valide.
					Ensuite, on effectue un certain nombre d'itérations de recuit simulé : on choisi un sous-ensemble dans \(S\) aléatoirement
					et on l'enlève, puis on complète de manière vorace de manière à obtenir une autre solution valide \(S'\). Si \(S'\)
					est une meilleure solution que \(S\), \(S'\) remplace \(S\), sinon il remplace avec une certaine probabilitié qui
					décroit exponentiellement au fil des itérations.~\cite{jacobs1995lsh}
				\paragraph*{}
					\citeauthor{Brusco1999} ont ensuite proposé une amélioration à cette méthode.
					Premièrement, au lieu de choisir le sous-ensemble à enlever aléatoirement à chaque itération, on ne le fait plus
					que toutes les trois itérations. Pendant les deux itérations restantes, on choisi simplement le sous-ensemble qui
					laisse le moins de point non couvert possible. Deuxièmement, pour chaque sous-ensemble \(j\) de la solution,
					on utilise une liste de « morphs », qui sont tout simplement les autres sous-ensembles « similaires » à \(j\).
					Après avoir obtenu la solution partielle et tous les quatre sous-ennsemble ajouté pour la compléter, on itère
					sur tous les sous-ensembles de la solution partielle courante
					et on remplace chaque sous ensemble par l'un de ses « morphs » si cela améliore le ratio entre le coût actuel
					et le nombre de point couverts.~\cite{Brusco1999}
				\paragraph*{}
					\citeauthor{Afif1995} ont présenté une solution basée sur l'algorithme du flot de Ford-Fulkerson qui est un algorithme
					en temps polynomial.
					Il s'agit d'effectuer une transformation du problème en un graphe de flot à résoudre par une variante de l'algorithme
					de Ford-Fulkerson. Il est montré que le problème de couverture d'ensemble peut se réduire à un problème de flot minimal
					en temps polynomial.~\cite{Afif1995}
	\section{Représentation du problème}
		\subsection{Représentation mathématique}
			\paragraph*{}
				On reprend la notation:
				\begin{itemize}
					\item \(U = \{u_1, u_2, u_3, \dots, u_m\}\), ensemble univers composé de \(m\) points
					\item \(S = \{s_1, s_2, \dots, s_n\}\), famille de \(n\) sous-ensembles de \(U\)
				\end{itemize}
				et on pose \(M = \{1,\ldots,m\}\) et \(N = \{1,\ldots,n\}\).
			\paragraph*{Matrice d'incidence\\}
				On définit la matrice d'incidence \(A = \left(a_{i,j}\right)\) de taille \(m \times n\) avec
				\[\forall i \in M,\ \forall j \in N,\ a_{i,j} = \left\{
				    \begin{array}{ll}
				        1 & \text{si } u_i \in s_j \\
				        0 & \text{sinon}
				    \end{array}
				\right.\]
				\(a_{i,j} = 1\) signifiant donc que le point \(i\) est couvert par le sous-ensemble \(j\).
			\paragraph*{Vecteur coût\\}
				On définit le vecteur coût \(n\)-dimensionnel \(c = \left(c_j\right)\) avec \(\forall j \in N\), \(c_j\) le coût du sous ensemble \(j\).
			\paragraph*{Solution\\}
				On définit un vecteur solution comme un vecteur \(n\)-dimensionnel \(x = \left(x_j\right)\) avec
				\[\forall j \in N,\ x_j = \left\{
				    \begin{array}{ll}
				        1 & \text{si } u_i \text{ fait parti de la solution}\\
				        0 & \text{sinon}
				    \end{array}
				\right.\]
				La solution ayant comme coût \(\sum_{j \in N}{c_i x_i}\) et étant valide si
				\[\forall i \in M\ ,\sum_{j \in N}{a_{ij}x_i} \ge 1\]
		\subsection{Représentation dans notre projet}
			\paragraph*{}
				TODO: bitset\ldots
	\section{Instances du problème}
		\paragraph*{}
			On utilise les groupes d'instances mis a disposition par \citeauthor{OR-Library} dans son regroupement d'instances OR-Library\cite{OR-Library}. Parmis ces instances, celles de 4 à 6 proviennent l'article \citetitle{Balas1980}\cite{Balas1980} de \citeauthor{Balas1980}, celles de A à D proviennent de l'article \citetitle{Beasley1987}\cite{Beasley1987} de \citeauthor{Beasley1987} et celles de E à H proviennent de l'article \citetitle{Beasley1990}\cite{Beasley1990} de \citeauthor{Beasley1990}.
		\paragraph*{}
			Toutes les instances du problème de ces groupes on été générées en utilisant le shémas de \citeauthor{Balas1980}\cite{Balas1980} dans lequel le cout \(c_i\) de chaque colonne \(i\) est pris aléatoirement dans l'intervalle \(\llbracket0,100\rrbracket\), chaque colonne couvre au moins une ligne et chaque ligne est couverte par au moins deux clonnes.
		\paragraph*{}
		   Les propriétés de ces groupes d'instances sont décrites dans la table \ref{table:scp_problem_sets}, la densitée étant la proportion de \(1\) dans la matrice \(a_{i,j}\). La table \ref{table:problem_optimal_solutions}, contient les valeure optimales pour les problèmes pour lesquels elle est connue.
		\begin{table}[H]
			\centering
			\input{tables/orlibrary_scp_problem_sets}
			\caption{Groupes d'instances du SCP utilisées\cite{OR-Library,Balas1980,Beasley1987,Beasley1990}}
			\label{table:scp_problem_sets}
		\end{table}
		\begin{table}[H]
			\centering
			\begin{minipage}[t]{0.45\linewidth}
				\centering
				\input{tables/orlibrary_scp_problems_optimal_solutions_1}
			\end{minipage}
			\begin{minipage}[t]{0.45\linewidth}
				\centering
				\input{tables/orlibrary_scp_problems_optimal_solutions_2}
			\end{minipage}
			\caption{Solutions optimales des instances du SCP utilisée\cite{Beasley1990}}
			\label{table:problem_optimal_solutions}
		\end{table}
	\section{Méthode exacte}
		\paragraph*{}
			Il existe une méthode exacte plus efficace qui utilise la méthode Branch and Bound ainsi que le Simplexe (pour résoudre une version
			du problème linéaire relaxée)~\cite{caprara2000algorithms}.
	\section{Méthodes approchées}
		\subsection{Algorithmes voraces}
			\paragraph*{}
				Nous avons commencé par implémenter des algorithmes voraces qui permettent de trouver des solutions approchées très rapidement.
			\paragraph*{}
				Le premier algorithme que nous avons implémenté est celui de
				\citeauthor{Johnson:1973:AAC:800125.804034}~\cite{Johnson:1973:AAC:800125.804034} présenté dans la section~\ref{sec:soa-greedy}
				où l'on intègre dans la solution les sous-ensembles couvrant le plus de point d'abord.
				On utilise le nombre de points qu'un sous-ensemble permet de couvrir de façon non redondante comme score.
			\paragraph*{}
				Pour le problème \emph{A.1} dont la solution optimale est \(253\), on obtient la solution de coût \(1444\) suivante :
			\begin{lstlisting}
[info] found unweighted greedy solution with 42 subsets cost of 1444 in 0.108285s
[info] Unweighted greedy solution: scp::Solution{
	selected subsets number = 42,
	selected subsets = 7, 32, 112, 132, 134, 136, 188, 191, 244, 245, 248, 274, 299, 392, 399, 428, 548, 816, 819, 922, 925, 960, 1042, 1068, 1096, 1161, 1208, 1271, 1300, 1302, 1412, 1418, 1454, 1505, 1565, 1971, 2056, 2154, 2341, 2462, 2752, 2941, 
	cover all points = true,
	cost = 1444,
}\end{lstlisting}
			\paragraph*{}
				Pour un problème de couverture d'ensembles pondéré, cet algorithme est très mauvais.
				Nous avons donc décidé d'implémenter une version de l'algorithme qui prend en compte le coût des sous ensembles pour
				sélectionner lequel ajouter.
				Pour cela, nous utilisons le rapport \(\frac{n}{c}\) avec \(n\) le nombre de points actuellement non couverts que le
				sous-ensemble nous permettrait de couvrir et \(c\) le coût du sous-ensemble. C'est à dire le rapport de l'utilité sur
				le coût de la même façon que présenté dans le cours dans le chapitre sur les algorithmes voraces.
			\paragraph*{}
				De la même façon que précédememnt, pour le problème \emph{A.1} dont la solution optimale est \(253\), on obtient cette fois
				une solution de coût \(288\) :
			\begin{lstlisting}
[info] found weighted greedy solution with 89 subsets and cost of 288 in 0.564261s
[info] Weighted greedy solution: scp::Solution{
	selected subsets number = 89,
	selected subsets = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 27, 28, 30, 32, 33, 34, 37, 38, 39, 40, 42, 45, 46, 47, 48, 49, 50, 51, 54, 55, 59, 62, 63, 65, 66, 67, 69, 74, 76, 77, 78, 85, 86, 87, 88, 89, 90, 91, 92, 94, 97, 104, 105, 108, 112, 114, 115, 116, 117, 122, 123, 132, 137, 143, 162, 164, 172, 188, 189, 191, 214, 221, 268, 331, 
	cover all points = true,
	cost = 288,
}\end{lstlisting}
			\paragraph*{}
				Utiliser le ratio utilité / coût nous permet donc d'obtenir une solution bien meilleure. On constate que dans le cas du
				problème de couverture d'ensemble pondéré, la meilleure solution n'est pas toujours celle qui utilise le moins de
				sous-ensembles. En effet, cette dernière solution utilise \(89\) solutions contre \(42\).
		\subsection{Méta-heuristiques}
			\subsubsection{Recuit simulé}
				TODO
			\subsubsection{Algorithme génétique}
				TODO
	\section{Conclusion}
		\paragraph*{}
			En tant que problème NP complet, la méthode exacte avec le branch-and-bound peut être très rapide ou très lent selon la configuration du problème.
			Pour résoudre des problèmes de taille supérieure, il nous a fallu implémenter des méthodes approchées.
			TODO
	\newpage\printbibliography[heading=bibintoc]{}
\end{document}

% Problem set        Files
% 4                  scp41, ..., scp410
% 5                  scp51, ..., scp510
% 6                  scp61, ..., scp65
% A                  scpa1, ..., scpa5
% B                  scpb1, ..., scpb5
% C                  scpc1, ..., scpc5
% D                  scpd1, ..., scpd5
% E                  scpe1, ..., scpe5

% Problem set        Files
% E                  scpnre1, ..., scpnre5
% F                  scpnrf1, ..., scpnrf5
% G                  scpnrg1, ..., scpnrg5
% H                  scpnrh1, ..., scpnrh5
